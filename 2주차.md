## 2023-07-18

정규성
<details>
 <summary> 프로세스와 쓰레드의 컨텍스트 스위칭에 대해 설명해주세요 </summary>
</br>
    
   프로세스는 실행중인 프로그램, 스레드는 프로세스 내부의 하나의 실행흐름이라고 설명할 수 있습니다. 컨텍스트 스위칭이란, CPU에 할당된 프로세스와 스레드가 새로운 프로세스나 쓰레드로 바뀌는 과정을 말합니다.

이때 프로세스 간의 컨텍스트 스위칭은 메모리를 공유하지 않기 때문에 오래 걸립니다. 반면에 스레드, 더 자세히 말하면, 동일 프로세스 내의 스레드는 메모리를 공유하기 때문에 훨씬 가볍습니다.

++ 컨텍스트 스위칭 과정에 대해 더 자세히 설명해 줄래요?

 컨텍스트 스위칭 과정은 크게 4단계로 나뉩니다.

1. 현재 실행중인 프로세스(스레드) 의 context를 저장합니다.
2. CPU의 캐쉬를 비웁니다.
3. TLB 라고 불리는 버퍼를 비웁니다.
4. MMU 가 새로운 프로세스(스레드)를 바라볼 수 있도록 수정합니다.

이때 동일 프로세스 내부의 스레드간 컨텍스트 스위칭은 메모리를 공유하기 때문에 2, 3, 4를 실행하지 않습니다.
    
</details>

<details>
 <summary> 소켓 프로그래밍에 대해 설명해 주세요. </summary>
 <div markdown="1">
  </br>
  우선, 소켓은 4계층의 네트워크 통신에 쓰이는 연결부를 말합니다. 대표적으로 TCP 소켓이 있습니다. TCP 소켓을 사용하는 프로그래밍은 역할이 서버와 클라이언트의 소켓으로 나뉩니다.

1. 먼저 서버 역할의 소켓을 생성하고, 특정 포트로 연결하여 수신을 대기합니다.
2. 추후에 클라이언트가 소켓을 생성하고, 서버의 ip/port 로 연결을 요청합니다.
3. 서버 소켓은 이를 받아 연결을 위한 새로운 소켓을 생성해서 연결해 줍니다.
4. 이제부터는 서로 데이터를 주고 받을 수 있습니다. 
5. 연결을 종료할 때는 클라이언트는 자신의 소켓만 닫으면 되고, 서버는 클라이언트에게 할당해준 소켓과 연결 요청을 받기 위해 열어둔 소켓을 닫으면 됩니다.
</details>

  
조준희
<details>
 <summary> 콜백함수는 무엇인가? 콜백함수를 사용하는 이유는 무엇인가? </summary>
</br>
 함수는 일급객체로, 다른 함수의 인자로 전달되거나 함수의 리턴되는 값으로 사용될 수 있다. 
따라서 일급객체인 콜백함수는 다른 함수의 인자로 전달되며, 함수 내부에서 어떤 작업이 완료된 특정 시점에 실행될 수 있다. 보통 특정 이벤트 뒤에 발생하는 이벤트 리스너로 
사용하거나, 비동기처리 방식을 동기 처리 하는 방식으로 사용된다. 
</br>
 +++++++++ 비동기처리 방식을 동기 처리 하는 방식이 무슨 말이냐, 예시를 하나 들어봐라. 
 
함수 내에서 ajax,fetch와 같이 비동기로 데이터를 가져오고 변수에 저장하여 리턴하는 경우, 비동기이기 때문에 데이터를 가져오기도 전에 다음코드를 실행하게되고 결국 변수에 데이터가 제대로 저장이 되지 않은 채로 함수가 종료가 된다. 이때 비동기 함수 뒤에 콜백함수(데이터를 변수에 저장하는 함수)를 호출하여 비동기함수가 처리 된 이후에 해당 콜백함수를 호출하도록 할 수 있다.
</details>

<details>
 <summary> 자바스크립트는 싱글스레드 언어인데, 어떻게 비동기 처리가 가능한지 설명해봐라. </summary>
</br>
 자바스크립트는 실행엔진 뿐만아니라 실행에 관여하는 Web API와 Callback Queue(Task Queue), Event Loop가 존재한다. 이때 Web API가 비동기 작업을 실행엔진의 call stack으로부터 전달받아 대신 수행하는 역할을 맡게된다. 그렇게 비동기 작업이 완료되면 callback Queue로 넘겨져서, 실행 엔진의 call stack에 들어가기 위해 대기하고 Event Loop에 의해 call stack으로 들어가 실행되게 되는 것이다. 
</br>
 +++++++++ Event Loop는 어떻게 동작하냐? 
 
 Event Loop는 계속해서 call stack에 모든 작업이 완료되어 비어있는지, Callback Queue에서 대기하고 있는 작업이 있는 지를 확인하며 두가지가 모두 충족된다면 대기하고 있는 작업을 call stack에 옮겨 작업을 실행하도록 한다.
</details>


## 2023-07-19

정규성
<details>
 <summary> MSA 아키텍쳐에 대해 설명해주세요 </summary>
</br>
 MSA는 하나의 프로그램을 만들 때 각 컴포넌트로 구성하여 하나의 큰 프로그램을 만드는 방식입니다. 이때 각 컴포넌트는 하나의 서비스 단위로 구성합니다. 예를 들면 회원을 관리하는 서비스, 상품을 등록하고 보여주는 서비스, 상품을 주문하고 결재하는 서비스를 나누어 제공할 수 있습니다.

++ 장단점에 대해 설명해주세요

각 서비스는 독립된 서버에서 동작하므로 독립적으로 배포할 수 있습니다. 즉, 다른 서비스에 문제가 생겨도 문제없이 동작할 수 있습니다. 또한 한 서비스에 트래픽이 몰린다면 해당 서비스만을 확장하면 됩니다.

다만 서버가 나눠져 있기 때문에 각 서버간 통신에 네트워크 통신이 필요합니다. 또한, 여러 곳의 서비스가 유기적으로 동작하는 경우 문제를 파악하기 어려우며, DB의 트랜젝션을 관리하기 어렵습니다.
</details>

<details>
 <summary> filter 와 interceptor 의 차이점에 대해 설명해주세요 </summary>
 <div markdown="1">
  </br>
  둘 모두 String 프레임워크와 같이 사용되는 기능입니다. 특정 요청의 전/후로 공통 작업을 쉽게 실행한도록 도와줍니다.

filter 는 dispatcher servlet 의 전후에서 부가 작업을 진행합니다. 즉, spring으로 들어가기 전에 작업을 처리합니다.

interceptor는 spring 내부에서 dispatcher servlet 이 controller 를 호출하기 전후로 작업을 진행합니다.

++ 각 기능의 예시를 들어서 설명해주세요

filter는 모든 요청에 대한 작업이므로 XSS와 같은 공통된 보안작업을 진행하거나, 요청 단위의 로깅, 인코딩 등의 기능을 담당하고, request, response 의 객체를 조작할 수도 있습니다.

interceptor는 클라이언트의 요청에 대해 전역적으로 처리해야 하는 작업을 처리합니다. 특정 요청의 권한이 있는지 확인하거나, api 단위의 로깅, httpServletRequest/response 의 조작 권한이 주어집니다.
</details>

  
조준희
<details>
 <summary> SpringBoot AutoConfiguration에 대해 설명해봐라. </summary>
</br>  
 스프링부트는 자동구성(Auto Configuration) 기능을 지공하는데, 일반적으로 수많은 빈들을 자동으로 등록해주는 기능이다. 이러한 기능으로 인해 반복적으로 빈을 등록하고 설정하는 부분을 줄이고 편리한 개발을 할 수 있게 도와주며 스프링 부트의 핵심적인 장점이라고 할 수 있다.  
 
------------------------------------------------------  
 
++ Auto Configuration이 어떻게 동작하는지 설명해봐라.  
main 메소드를 살펴보면 @SpringBootApplication이 붙어있고, 이 어노테이션을 통해 필요한 Bean 객체를 등록하고 스프링부트를 실행하는 것이다. @SpringBootApplication 어노테이션은 들어가보면 빈등록에 관여하는 2가지 단계가 있다.  
1. @ComponentScan : 자기 자신부터 시작해서, 하위 패키지를 훑으면서 @Component 어노테이션 붙어있는 객체들을 스캔하면서 자동으로 빈 객체로 등록해준다.
2. @EnableAutoConfiguration :  Spring Boot Dependency jar 파일 내에 spring.factories 파일을 열면 자동 설정 목록을 확인 할 수 있습니다. 이 목록에서 설정 환경에 따라 자동으로 선별하여 빈 객체로 등록을 해줍니다.
 
</details>

<details>
 <summary> Filter 와 Interceptor의 차이점을 설명해봐라. </summary>
</br> 
 필터와 인터셉터의 가장 큰 차이점은 적용되는 시점이라고 생각합니다. 필터같은 경우에는 스프링 컨텍스트 영역에 들어가기 전과 후에 적용되는 것이고, 인터셉터는 스프링 컨텍스트와 컨트롤러 사이에서 적용되는 것이 큰 차이입니다.  
 
--------------------------------------------------------------  
 
++ 적용시점이 다른 차이점은 알겠는데 필터와 인터셉터는 어떤 작업의 차이가 있는지 설명해봐라. 
 
필터는 보통 공통된 보안 및 인증 작업, XSS방어, 데이터 인코딩에 사용됩니다. 그리고
인터셉터는 세부적인 보안 및 인증, API 호출에 대한 로깅, Controller로 넘겨주는 데이터의 가공등에 사용됩니다.
</details>


## 2023-07-20

정규성
<details>
 <summary> spring 에 대해 설명해주세요. </summary>
</br>
 spring 은 자바를 활용하여 웹 개발을 할 수 있는 프레임워크입니다.  일부 설정만 진행하면 사용자가 제공하는 비지니스 로직의 개발에만 집중할 수 있습니다. 제어의 역전, 의존성 주입 등, AOP 등의 특징을 기반으로 쉽게 웹 개발을 진행할 수 있습니다.

++ spring 의 특징에 대해 자세히 설명해 주세요

크게 5가지가 있습니다.

1. POJO : 일반적인 기능만을 가진 자바 객체를 활용합니다. 즉, 불필요한 불필요한 상속이나 구현을 지양하는 방식입니다.
2. IoC(제어의 역행) : 어플리케이션의 느슨한 결합을 도모합니다. 제어권을 사용자가 가지는 것이 아니라 스프링이 제어권을 가지는 것입니다.
3. DI(의존성 주입) : 객체를 직접 생성하는 것이 아니라 외부에서 생성한 객체를 주입받는 방식입니다.
4. AOP : 관점 지향 프로그래밍을 지원합니다. 원하는 기능을 모듈화하여 반복되는 코드 작업을 줄일 수 있습니다. Spring 의 bean 단위로 등록할 수 있습니다.
</details>

<details>
 <summary> spring과 spring boot 의 차이점을 설명하세요 </summary>
 <div markdown="1">
  </br>
  spring 은 자바를 활용하여 웹 개발을 할 수 있는 프레임워크입니다. spring에서는 bean 등록이나  외부 라이브러리와의 연동을위해 직접 xml 파일을 열고 작업했으며, WAR 파일을 만들고 이를 웹 서버에 배포하여 실행해야 합니다.

spring boot 는 spring에서 이런 복잡한 설정부분을 쉽게 설정할 수 있으며, JAR 파일로 만들어 클라우드나 도커와 같은 환경에서 쉽게 실행할 수 있습니다.
</details>

  
조준희
<details>
 <summary> 모놀리식 아키텍쳐와 MSA 아키텍쳐의 각 특징과 차이점에 대해 설명해봐라. </summary>
</br>  
 모놀리식 아키텍쳐는 여러 비즈니스 로직들을 담은 하나의 시스템이 하나의 DB, 어플리케이션과 상호작용한다. 그렇기 때문에 규모가 작은 프로젝트에서는 개발과 관리가 용이하다는 장점이 있으나, 시스템이 복잡해질수록 코드의 양이 많아져 이해하기가 어려워지고 그럴수록 유지보수성은 떨어진다는 특징을 가지고 있다. 또한 작은 버그를 수정하더라고 전체를 다시 빌드, 배포해야된다는 단점을 가지고 있다.
 이런 모놀리식의 단점을 해결하기 위해 나온 것이 MSA(MicroService 아키텍쳐)이다. MSA 아키텍쳐는 기능마다 여러 모듈이 독립적으로 존재하여 이를 조합하여 하나의 어플리케이션을 구현하는 방식이다. 기능마다 독립적으로 구성되어 있어서 코드를 이해하기 쉬우며 그만큼 유지보수하기 쉽다. 또한 상대적으로 빌드 및 배포가 빠르며 작은 버그가 전체에 영향을 주지 않는다는 특징을 가지고 있다. 하지만 이또한 단점을 가지고 있는데, 하나의 어플리케이션이 여러 모듈로 분산되어 있어 관리 및 모니터링이 힘들다. 또한 모듈별로 어플리케이션과 각각 통신하므로 다양한 통신에서 발생하는 오류가 상대적으로 잦다.

 ++ 그런 어느것을 어디에 사용하는 것이 좋을까?  
 서비스의 확장 가능성이 낮거나 시스템이 크지 않다면 모놀리식 아키텍쳐를 사용하고,  
 서비스의 확장 가능성이 높거나 시스템이 크다면 MSA 아키테겨를 사용하는 것이 좋다고 생각한다.
</details>

<details>
 <summary> SSR과 CSR의 특징과 차이점에 대해 설명해봐라. </summary>
</br> 
 SSR이란 서버사이드 렌더링의 약자로 서버로부터 즉시 렌더링 가능한 html파일을 받아와 페이지 전체를 렌더링 하는 방식이다. 그렇기때문에 클라이언트에 전달되는 순간 HTML이 즉시 렌더링되어 초기 로딩 속도가 빠릅니다. 하지만 이런 특징 때문에, JS를 읽어드리는 시간과의 간격이 존재하게 되어 사용자가 버튼을 클릭하거나 이동하려고 해도 아무런 반응이 없을 수가 있다. 또한 매번 페이지를 요청할 때마다 서버는 페이지를 구성하는 모든 리소스를 준비해서 응답하므로 서버 부담이 증가할 뿐아니라 전체 페이지를 다시 렌더링하여 화면이 깜빡이게 된다. 이는 사용자 경험을 다소 떨어지게 한다.  
 CSR은 클라이언트 사이드 렌더링으로 클라이언트에서 렌더링하는 방식이다. 클라이언트가 초기화면을 로드하기 위해 서버에 요청을 보내면, 서버는 화면을 표시하는 데 필요한 렌더링 되지 않은 HTML과 모든 로직이 담겨있는 JS 파일을 보낸다. 그렇기 때문에 크기가 큰 JS를 다운받는 과정에서 초기 로딩 속도가 SSR에 비해 느리다. 하지만 그 이후부터는 서버로부터 필요한 데이터만을 불러와서 페이지 전체를 다시 렌더링하지않고, 수정이 필요한 부분만 동적으로 렌더링한다. 그렇기때문에 서버의 부하가 적고, 전체 페이지를 받아오면서 발생하는 깜빡임같은 현상을 없애주기 때문에 사용자 경험측면에서 좋은 방식이다.
</details>


## 2023-07-21

정규성
<details>
 <summary> 서버와 클라이언트의 인증방식에 대해 설명해주세요. </summary>
</br>
 서버는 서비스에 대해 아무나 접근할 수 없도록 클라이언트에 대한 인증을 진행해야 합니다. 인증 방식은 크게 cookie, session, token 인증 방식이 있습니다. 

- cookie 방식은 클라이언트가 정보를 가지고 요청때 마다 cookie 정보를 기반으로 인증을 진행합니다.
- session 방식은 정보를 서버에서 저장하고 관리하는 방식입니다. 요청마다 서버에 저장된 session 정보를 통해 인증을 진행합니다.
- Token 방식은 접속과 동시에 고유의 토큰을 발급하고, 요청마다 토큰을 보내 유효한 지만 확인하는 방식입니다.

++ 각 방식에 대한 장단점에 대해 설명해 주세요.

- cookie는 보안에 사용되는 값을 그대로 보내기 때문에 보안에 취약한데신, 용량에 제한이 없이 많은 데이터를 보낼 수 있습니다.
- session 은 그 자체로 데이터를 가지지 않기 때문에 탈취당하더라도 상관없지만, session을 서버에서 관리하기 때문에 부하가 심해질 수 있습니다.
- token 방식은 클라이언트가 관리하기 때문에 서버에 부하가 덜 가고, 모바일 앱에서 활용이 가능하지만, 자체 길이가 길어 네트워크 부하가 크고, 보안 기능을 가지진 않기 때문에 탈취 당할 시 대처가 어렵습니다.
</details>

<details>
 <summary> JWT 토큰 인증방식에 대해 설명해주세요. </summary>
 <div markdown="1">
  </br>
  JWT 는 인증에 사용되는 정보를 암호화한 JSON 토큰입니다. 이 토큰을 사용하여 HTTP 해더에 담아 전송하여 토큰 인증방식을 진행합니다. JWT 토큰 구조는 header, payload, signature 로 나뉩니다. header 에는 타입과 해시 알고리즘의 종류가 들어있고, payload 에는 사용자 정보가 들어있고, signature에는 전자서명이 들어있습니다. 

세부적인 인증과정은 다음과 같습니다.

1. 사용자 로그인 요청
2. 서버에서 로그인 데이터를 기반으로 JWT 생성하고 클라이언트로 전송
3. 클라이언트는 이를 받아 로컬에 저장하고 요청마다 header에 담아 보냄
4. 서버는 토큰을 받았다면 유효한지 검사하고 통과
5. 액세스 토큰이 만료되었다면 리프레시 토큰을 확인하여 엑세스 토큰 재발급
</details>

  
조준희
<details>
 <summary> Spring 과 SpringBoot의 차이점을 설명해보시오. </summary>
</br>  
Spring은 스프링 프레임워크의 핵심 모듈을 모아서 만든 프레임워크입니다. Spring에서는 개발자가 직접 설정 파일을 작성하여 스프링 컨테이너를 구성하고, 필요한 빈 객체를 등록하고, 빈 객체 간의 의존성을 설정해야 합니다. 이렇게 Spring은 특정한 구성을 위해 추가적인 라이브러리와 설정이 필요합니다. 반면 Spring Boot에서는 개발자가 설정 파일을 작성할 필요 없이, 프로젝트의 설정과 라이브러리 의존성을 자동으로 처리해주는 기능을 제공합니다. 예를 들어, Spring Boot는 스프링 MVC, 스프링 Data JPA, 스프링 Security 등의 기능을 자동으로 설정하며, 개발자가 별도로 설정 파일을 작성하지 않아도 사용할 수 있습니다.
</details>

<details>
 <summary> Spring Security에 대해 설명해봐라 </summary>
</br>
 스프링 시큐리티 (Spring Security)는 스프링 기반 어플리케이션의 보안(인증과 권한, 인가)을 담당하는 스프링 하위 프레임워크이다. 필터기반으로 작동하며 보안과 관련해서 체계적으로 많은 옵션들을 제공해주기 때문에 개발자의 입장에서는 하나하나 보안 관련 로직을 작성하지 않아도 된다는 장점이 있다.  


  
++ 로그인 과정에서 Spring Security의 동작과정을 상세하게 설명해봐라. 

1. 사용자가 아이디 비밀번호를 가지고 서버에게 request요청
2. AuthenticationFilter에서 아이디, 비밀번호 정보를 담은 인증 객체인UsernamePasswordAuthenticationToken을 생성하여 AuthenticationManager에게 전달함
3. AuthenticationManager는 등록된 AuthenticationProvider(들)을 조회하여 인증을 요구함
4. AuthenticationProvider는 UserDetailsService를 통해 입력받은 아이디에 대한 사용자 정보를 DB에서 조회함
5. 입력받은 비밀번호를 암호화하여 DB의 비밀번호와 매칭시켜 일치하는 경우 인증된 UsernamePasswordAuthenticationToken을 생성하여 AuthenticationManager에 전달함
6. AuthenticationManager는 UsernameAuthenticationToken을 AuthenticationFilter로 전달함
7. AuthenticationFilter는 전달받은 UsernameAuthenticationToken을 LoginSuccessHandler로 전송하고, SecurityContextHolder에 저장함
8. 다음번 로그인때부터, security context holder에 해당 사용자에 대한 세션ID가 있는지 확인 후 1-7과정을 수행
</details>


## 2023-07-22

정규성
<details>
 <summary> 힙에 대해 설명해 주세요. </summary>
</br>
 힙은 우선순위 큐를 구현하는 자료구조 입니다. 우선순위 큐란, 수선순위에 맞춰 데이터가 정렬되어 항상 우선순위가 높은 데이터를 바로 찾을 수 있는 자료구조입니다. 우선순위에 따라 최대 힙, 혹은 최소 힙으로 나뉩니다. 완전 이진 트리 구조이며 루트 노드가 가장 우선순위가 높습니다. 구현은 주로 배열을 사용합니다. 

0번 인덱스를 사용하지 않고 

왼쪽 자식은 2를 곱하고, 오른쪽 자식은 2를 곱하고 1을 더하면 됩니다.

힙에 데이터를 넣을 때는 마지막 노드에 데이터를 넣고 부모 노드와 비교하면서 위로 올라갑니다.

힙에서 데이터를 삭제할 때는 1번 익덱스의 데이터를 삭제하고 마지막 노드를 1번에 넣고 트리를 재구성합니다.
</details>

<details>
 <summary> 좌표압축 알고리즘에 대해 설명해주세요. </summary>
 <div markdown="1">
  </br>
  문제에서 제공하는 수의 범위가 커서 완전탐색으로는 좌표값을 모두 탐색할 수 없을 때, 좌표 압축을 통해 탐색 범위를 줄일 수 있습니다.

1. 탐색을 진행하는 배열을 중복을 제거하고 정렬된 상태로 만듭니다.
2. 이제 원래 배열을 돌면서 각 수가 정렬된 상태일 때 몇 번째 인덱스에 있는지 찾고 압축 배열에 기록합니다.

이젠 모든 인덱스를 돌 필요없이 압축 배열을 보면 됩니다.

모든 좌표 문제에 적용한다고 효과가 월등히 좋아지지는 않습니다. 실제 좌표에 비해 사용하는 좌표가 현저하게 적은 경우 유효합니다.
</details>

  
조준희
<details>
 <summary> XSS 공격에서, Reflected XSS와 Stored XSS의 차이점에 대해 설명해봐라. </summary>
</br>  
</details>

<details>
 <summary> Servlet Filter는 이런 XSS 공격을 어떻게 방어하는지 설명해봐라. </summary>
</br>
</details>
