
## 2023-07-25

정규성
<details>
 <summary> 1 </summary>
</br>
</details>

<details>
 <summary> 2 </summary>
  </br>
</details>

  
조준희
<details>
 <summary> 프로세스와 스레드의 차이를 설명해봐라. </summary>
</br>  
 프로세스는 메모리 상에서 실행중인 프로그램을 의미하며, 스레드는 이 프로세스 안에서 실행되는 흐름의 단위를 의미한다.  
프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 각 프로세스는 별도의 주소 공간에서 실행되어 프로세스간 자원에 접근할 수 없다. 만약 프로세스간 자원에 접근하려면 IPC 통신을 사용하면 가능하다.  

  
이에 반해 스레드는 "한 프로세스 내에서" 각각 자신만의 Stack영역만 따로 할당받고 Code, Data, Heap 영역은 서로 자원을 공유한다. 그렇기 때문에 프로세스의 컨텍스트 스위칭 비용, 프로세스간 통신(IPC) 비용을 줄일 수 있는 이점이 있다. 하지만 한 프로세스 내의 스레드는 스레드간 공유 자원에 접근하면서 동기화 문제가 발생할 수 있다는 특징을 가지고 있다.
</details>

<details>
 <summary> 프로세스와 스레드의 컨텍스트 스위칭 비용이 차이가 나는 이유를 자세하게 설명해봐라. </summary>
</br>  
 컨텍스트 스위칭은 다음과 같은 순서로 작업을 수행한다.  
 
 1. 현재 실행 중인 프로세스 혹은 스레드의 정보를 백업
      
 2. 캐시를 비운다.
  
 3. TLB를 비움.
  
 4. MMU를 변경.
    
이때 프로세스 컨텍스트 스위칭은 새로 실행되는 프로세스가 이전의 프로세스와 공유하는 메모리 자원이 전혀 없기 때문에 1,2,3,4번을 모두 수행하면서 이전 프로세스에 대한 정보를 모두 지운다. 반면 스레드 컨텍스트 스위칭의 경우에는 메모리 주소 공간이 바뀌지 않기 때문에 2,3,4번의 작업이 수행되지 않고 1번 작업만 수행된다. 이런 차이에서 스레드 컨텍스트 스위칭이 프로세스에 비해 가벼운 것이다.
</details>

조준희
<details>
 <summary> Spring과 SpringBoot의 차이점이 무엇이며 어떤 특징을 가지고 있는지 자세하게 설명해봐라. </summary>
</br>  
 가장 큰 차이점은 개발 편의성이라고 생각한다.  
 Spring은 초기 설정이 반이라는 말이 나올정도로 개발을 시작하기에 앞서 해야할 설정들이 많다. 필요한 라이브러리들을 pom.xml, 빌드도구(Gradle, Maven)를 통해 하나하나 추가해줘야하며, 이 라이브러리에 대한 설정과 버전관리 또한 개발자의 몫이다. SpringBoot는 이러한 복잡한 설정들을 starter-dependency, AutoConfiguration를 이용해 의존성에 라이브러리를 쉽게 추가하고, 이에 대한 자동 설정(추가한 라이브러리에 대한 자동설정, Spring이 자주 사용하는 설정중에 log4j, tomcat, Dispatcher Servlet등등의 자동설정) 및 빈으로 등록하여 사용하므로써 개발자의 개별 편의성을 향상시킬 수 있다. 
</details>

<details>
 <summary> Spring에서 IoC/DI(제어의 역전/의존성 주입)에 대해서 자세하게 설명하고 어떤 이점이 있는지 설명해라. </summary>  
 우리가 그동안 작성해왔던 일반적인 프로그램은 객체의 생성, 초기화, 소멸, 메서드 호출과 같은 생명주기를 클라이언트가 직접 구현하여 관리했었다. 또한 라이브러리를 호출하더라도 해당 코드의 실행 역시 직접 제어했었다. 하지만 Spring 프레임워크에서는 Controller, Service, Repository와 같은 객체들을 구현은 하지만, 해당 객체들이 어느 시점에 호출될 지는 개발자가 신경쓰지 않는다. 단지 프레임워크의 요구대로 객체를 구현만 해놓는다면, 프레임워크가 해당 객체를 생성하고, 메서드를 호출하고 소멸시킨다. 이렇게 흐름의 제어권이 넘어간 것을 IoC라고 한다.  
  DI는 IoC의 개념을 구현한 디자인 패턴 중 하나로, DI(dependency Injection) 이름 그대로 객체의 의존관계를 외부에서 주입시키는 패턴을 의미한다. 보통 일반적으로 우리는 한 A 객체안에서 필요한 다른 B객체를 직접 생성하고 사용했었다. 하지만 이렇게되면 B 객체의 정보가 변경되었을 시, A객체의 정보를 수정해야하고 이를 객체간의 결합도가 높다고 표현한다. 객체간의 결합도가 높으면 변경에 대한 유지보수가 힘들어지는 단점을 가지고 있는데, 이를 해결하기 위한 개념이 바로 DI 의존성 주입이다. 의존성 주입은 필요한 객체를 직접 생성하는 것이 아니라 외부로부터 주입받아서 객체간의 느슨한 결합을 유지할 수 있도록 하는 개념이다. 주입 방식에는 필드주입, 생성자 주입, setter 주입이 있다.
</br>  
 
</details>


