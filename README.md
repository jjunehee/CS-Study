# CS-Study


## 2023-07-10

정규성
<details>
 <summary> OSI7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명해보세요. </summary>
</br>
    
   OIS7계층은 네트워크 통신이 일어나는 과정을 7단계로 나눈것이다. 이렇게 하면 통신이 일어나는 과정을 단계별로 파악할 수 있으며, 문제가 발생할 경우 해당 부분만을 고쳐서 해결할 수 있다. 다만 실제로 구현한 예는 거의 없다.
    
   1. 물리계층 : 신호로 변환하여 전송하는 계층 (허브, 케이블)
   2. 데이터 링크 계층 : 패킷 데이터를 실어 보내는 계층 (스위치, 브릿지)
   3. 네트워크 계층 : 네트워크를 논리적으로 구분하고 연결하는 계층(라우터 + 라우팅 프로토콜)
   4. 전송  계층 : 서비스를 구분하고 데이터의 전송 방식을 담당하는 계층(TCP, UDP)
   5. 세션 계층 : 응용 프로그램 간의 연결을 지원해주는 계층
   6. 표현 계층 : 데이터의 변환 작업을 하는 계층(데이터 암호화, 복호화)
   7. 응용 계층 : User Interface 를 제공하는 계층(chrome, discord, 한글)
    
  그에 비해 TCP/IP 4계층은 실질적인 네트워크 통신에 사용된다. 7계층의 1, 2 가 하나로 통합되고, 5, 6, 7 이 하나로 통합된다. 
    
   1. Network Access Layer : 네트워크 카드와 디바이스 드라이버 등과 같이 하드웨어적인 요소와 관련되 는 모든 것을 지원하는 계층(CSMA/CD, MAC, LAN + Ehternet(이더넷), Token Ring, PPP)
   2. Internet Layer : 상위 트랜스포트 계층으로부터 받은 데이터에 IP패킷 헤더를 붙여 IP패킷을 만들고 이를 전송하는 계층(IP, ARP, RARP)
   3. Transport Layer : 네트워크 양단의 송수신 호스트 사이에서 신뢰성 있는 전송기능을 제공(TCP, UDP)
   4. Application Layer : 응용프로그램들이 네트워크서비스, 메일서비스, 웹서비스 등을 할 수 있도록 표준적인 인터페이스를 제공(HTTP, FTP, Telnet, DNS, SMTP)

    
   </p>
</details>

<details>
 <summary> 프로세스 동기화에 대해 설명해보세요. </summary>
 <div markdown="1">
  </br>
  두 개 이상의 프로세스가 동일한 자원에 접근하면 데이터의 일관성을 해칠 수 있다.
    
   이런 상황을 경쟁상황(race condition)이라고 부른다.
    
   이런 상황을 유발할 수 있는 코드를 임계 구역(Critical Section)이라고 부른다.
    
   이를 해결하기 위해서는 3가지 조건을 만족해야한다.
    
   1.  Mutual Exclusion (상호 배제)
        
        이미 한 프로세스가 Critical Section에서 작업 중이면 다른 모든 프로세스는 Critical Section에 진입하면 안 된다.
        
   2. Progress (진행)
        
        Critical Section에서 작업 중인 프로세스가 없다면, Critical Section에 진입하고자 하는 프로세스가 존재하는 경우 진입할 수 있어야 한다.
        
   3. Bounded Waiting (한정 대기)
        
        프로세스가 Critical Section에 들어가기 위해 요청한 후부터, 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에 한계가 있어야 한다. 쉽게 말해, Critical Section에 진입하려는 프로세스가 무한정 기다려서는 안 된다. 
        
        ⇒ 모종의 이유로 아무도 사용하지 않는 자원을 무한정 기다려서는 안된다.
</details>
   
<details>
 <summary> RDBMS vs NOSQL에 대해서 설명해주세요. </summary>
 </br>
 <div markdown="1">
  <p>RDBMS 는 정해진 스키마에 따라 데이터를 저장하고 구성된 테이블이 다른 테이블과 관계를 맺는다. 이를 위해 외래키를 사용하며, 이를 통해 테이블을 통합하여 데이터를 얻을 수 있다. 데이터 구조화하여 정의하기 편하다. 성능향상을 위해서 서버의 처리 능력 향상이 필요하다. scale up</p>

    
   <p>NOSQL 은 테이블 간의 관계를 정의하지 않고 저장한다. 데이터의 일관성을 포기하고 빅데이터 트래픽 처리에 장점을 가진다. 성능향상을 위해서 분산처리를 지원한다. scale out(수평 확장)</p>
</details>
  
조준희
<details>
 <summary> RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요.(보충필요) </summary>
 <div markdown="1">

  REST의 원리를 잘 따르는 시스템, 그중에서도 REST API 설계 규칙을 올바르게 따르는 시스템을 Restful하다고 할 수 있다.
  
  이때 REST란,
  1. HTTP URI 를 통해 자원을 명시하고
  2. HTTP Method(GET, POST, PUT, DELETE) 를 통해
  3. 해당 자원에 대한 CRUD(생성, 조회, 수정, 삭제)를 적용하는 것을 의미한다.

  라고 보통 알고있는데, "REST란 HTTP 를 잘 사용하기 위한 아키텍쳐 스타일"이 더 알맞다.

  REST의 특징으로는,
  1. Client-Server
     - API를 통해 정보를 교환하는 주체는, 클라이언트와 서버 구조를 가져야한다.
     - 클라이언트와 서버를 분리함으로써, 서로 의존하지 않는 구조를 가져야한다.
  2. Stateless
     - 무상태성 (서로의 상태를 기억하지 않는다.)
     - 클라이언트에서 서버로의 요청에는 그 요청을 이해하는 데 필요한 모든 정보가 포함되어있어야한다.
  3. Cache
     - cache-control header를 통해 요청에 대한 응답 내의 데이터에 캐시 가능여부가 명시되어 있어야한다.
  4. Uniform Interface (.....? 이해가 안간다.. 이건...)
     - 전체 시스템을 파악할 수 있는 인터페이스를 제공해야한다.
  5. Layered System
     - 계층화 시스템
     - 클라이언트는 서버에 직접 연결되었는지, 중간 서버를 통해 연결되었는지 알 수 없어야함을 의미합니다.
     
  또한 REST API란, REST 한 방식으로 데이터를 상호교환 하도록 설계된 API를 의미하고, 이를 올바르게 설계하기 위한 규칙이 존재한다.
  1. URI는 동사보다 명사를, 대문자보다는 소문자를 사용해야한다.
  2. 마지막에 슬래시(/)를 사용해서는 안된다.
  3. 언더바 대신, 하이픈(-)을 사용한다.
  4. 파일확장자는 URI에 포함하지 않는다.
  
</details>

<details>
 <summary> 프로세스와 스레드의 차이를 설명해보세요. </summary>
 <div markdown="1">
  프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.
  
  프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)를 사용해야 한다.
  
  이에 반해 스레드는 한 프로세스 내에서 각각 Stack만 따로 할당받고, Code, Data, Heap 영역에서 서로 자원을 공유하고 접근할 수 있다. 따라서 프로세스간 통신이 불가해서 오는 컨텍스트 스위칭 비용, 프로세스간 통신(IPC)비용을 줄일 수 있는 이점이 있다. 하지만 스레드 간의 자원 공유는 동기화 문제가 발생할 수 있다는 특징이 있다.

+ 추가 질문 ( 컨텍스트 스위칭, IPC에 대해 설명해봐라, 메모리 영역(Code, Data, Stack, Heap)에 대해 설명해봐라, 동기화 문제는 무엇이고 어떻게 해결해야하는가?)
</details>
   
<details>
 <summary> ACID에 대해서 설명해주세요. </summary>
 <div markdown="1">

  Atomicity 원자성
  - 하나의 트랜잭션에 속한 모든 작업이 "전부 성공하거나 전부 실패"하는 것을 보장한다.

  Consistency 일관성
  - 트랜잭션이 성공적으로 끝나면 데이터베이스의 제약/규칙과 같은 상태는 언제나 이전과 같고 유효해야한다.

  Isolation 독립성
  - 트랜잭션은 다른 트랜잭션의 연산에 영향을 끼치지 못하는 것을 보장한다.
  - 모든 트랜잭션은 다른 트랜잭션으로부터 독립 되어야한다.

  Durabilty 지속성
  - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
</details>


## 2023-07-11

정규성
<details>
 <summary> apache 와 nginx, tomcat 의 역할과 차이점 </summary>
</br>
    apache는 웹 서버의 역할을 합니다. 멀티 프로세스 방식으로 동작하며 안정성에 장점이 있습니다. 다만 모든 연결에 프로세스를 할당하다보니 성능이 비교적 떨어집니다.

nginx는 마찬가지로 웹 서버의 역할을 하지만, 이벤트 기반 방식으로 동작합니다. 여기서 이벤트 기반 방식이란, 연결 요청이 nginx 가 가진 큐에 차례로 들어있다가 하나씩 요청을 스레드를 할당해 처리합니다. 이때 연결에서 별다른 요청이 없다면 다른 연결의 요청을 처리하는 방식입니다. 이를 통해 가볍고 성능이 비교적 좋습니다.

tomcat은 웹 어플리케이션 서버의 역할을 합니다. JAVA로 작성된 프로그램으로, http 요청을 받고 동적인 페이지를 만들어 제공하는 것이 목적으로 합니다. 웹 서버와 같이 연동해서 사용하면 성능을 향상시킬 수 있습니다.
   
</details>

<details>
 <summary> 컨텍스트 스위칭에 대해 설명해보세요. </summary>
</br>
   컨텍스트 스위칭은 여러개의 프로그램이 동시에 실행되는 경우 프로세스의 처리를 빠르게 바꿔가며 하기 위해 필요한 기술입니다.

이를 위해, 한 프로세스로 부터 CPU자원을 프로세스로 넘겨줍니다. cpu가 프로세스를 동작시킬 때 필요한 정보를 context라고 하며, 이 정보가 PCB에 저장됩니다. A프로세스가 실행중에 스케쥴러에 의해 B 프로세스의 실행을 요청하면 A의 정보를 PCB에 저장하고, B의 정보를 PCB로 부터 불러와서 작업을 진행합니다. 이럼

이때 어떤 프로세스를 요청할 지 여부를 결정하는 스케쥴링 방식에 따라 성능이 달라질 수 있으며, 이 과정이 과도하게 일어날 경우 오버헤드가 발생하며 오히려 성능이 저하될 수 있다.
   
</details>

<details>
 <summary> 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요. </summary>
</br>
   데이터베이스에서 인덱스를 사용하는 이유는 테이블에 대한 동작의 속도를 높이기 위해서입니다. 인덱스를 key-value 구조로 이루어지며, 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬하여 별도의 메모리 공간에 실제 메모리 주소와 함께 저장한다. 이를 구현하기 위해 여러 방법이 있지만, 주로 B+Tree 구조를 사용한다. B+tree 의 경우 balanced-tree 구조로 설계되어 수직탐색에 유리하며, leaf 노드에만 데이터를 저장하고 이를 linked-list로 연결하여 수평탐색에도 유리하다.
   
</details>

조준희
<details>
 <summary> TCP와 UDP의 차이점에 대해서 설명해보세요. </summary>
</br>
 TCP는 데이터의 신뢰성을 보장하는 연결 지향적 프로토콜이다.
 데이터의 손실이 없고, 순서대로 전달된다는 특징을 가지고 있다.
 TCP는 데이터를 전송하기 전에 송수신 기기간 논리적 연결을 하고, 이를 가상 회선이라고 한다.
 이렇게 생성된 회선을 통해 송신자는 패킷 전송이 잘 되었는지 확인하는 과정과 흐름제어 혼잡 제어와 같은 과정을 거치면서 패킷의 순서와 손실을 방지하면서 데이터 전송이 가능하게 해준다.

 UDP는 데이터의 신뢰성 보다는 전송 속도를 위한 비연결 지향적 프로토콜이다.
 데이터의 손실 가능성이 있어 데이터의 신뢰성은 보장할 수 없지만, 빠르게 데이터를 전송할 수 있다는 특징을 가지고 있다.
 UDP는 TCP와 다르게 가상회선 방식과 같이 연결을 설정하지 않고, 독집적인 데이터그램 형태로 패킷마다 각각 다른 경로로 수신자에게 보내지게된다. 이 때문에 데이터의 순서가 보장되지 못하며, 패킷이 잘 도착했는지 또는 흐름 제어와 혼잡 제어같은 기능을 처리하지 않기 때문에 데이터의 손실이 발생할 수 있다. 하지만 이로인해 네트워크 부하가 적어서 TCP보다 전송 속도가 빠르다.
</details>

<details>
 <summary> 동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요. </summary>
</br>
동기방식 : 호출된 함수의 수행 결과 및 종료를 호출한 함수가 신경쓰는 방식

비동기 방식 : 호출된 함수의 수행 결과 및 종료를 호출한 함수가 신경쓰지 않는 방식

블로킹 : 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않는 방식

논-블로킹 : 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return 하여 호출한 함수가 다른 일을 진행할 수 있도록 하는 방식

동기 & 블로킹, 비동기 & 블로킹 : 결국 호출된 함수가 끝날 때를 기다려야 하기 때문에 동기, 비동기에 상관없이 블로킹이라면 비슷한 효율을 가진다.

동기 & 논-블로킹 : 호출된 함수로부터 제어권을 바로 return 받아서 다른 작업을 수행할 수는 있지만 다른 작업을 하면서도 동기방식이기 때문에 호출된 함수의 결과를 계속 신경 쓰게 된다. 이로 인해 작업의 효율이 좋지 못하다.

비동기 & 논-블로킹 : 호출된 함수의 결과를 기다리지도 않으며 자신의 작업을 계속 수행하고, 콜백을 통해 호출된 함수의 결과를 받는다. 그렇기 때문에 자원이 충분하다면 효율이 좋은 방식이다.
   
</details>

<details>
 <summary> 정규화에 대해서 설명해주세요. </summary>
</br>
정규화의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는 것으로, 중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며, DB간의 저장 용량 역시 줄일 수 있는 방법이다.

따라서 테이블을 분해하는 여러 단계로 정의된다.

[제1정규화]
테이블의 칼럼이 원자값(하나의 값)을 갖도록 테이블을 분해한다.

[제2정규화]
테이블의 기본키의 부분집합이 결정자가 되어서는 안된다.
ex) 복합키 (A,B)가 기본키로 된 테이블에서 B만으로도 C가 달라지는 상황이 발생하면, 
B가 결정자가 되므로 이는 제2정규화의 대상이 된다.

[제3정규화]
테이블에 대해 이행적 종속을 없앤다.
여기서 이행적 종속이란 A -> B, B -> C 가 성립할 때, A-> C가 성립되는 상황을 의미한다.

[BCNF 정규화]
테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.
   
</details>



## 2023-07-12

정규성
<details>
 <summary> HTTP와 HTTPS의 차이점에 대해서 설명해보세요. </summary>
</br>
 http는 어플리케이션 레이어에서 동작하는 프로토콜입니다. 요청과 응답으로 구성됩니다. 브라우저 사용자가 웹 서버에 http get 요청을 보내면 웹 서버는 요청을 받고 이에 해당하는 암호화되지 않은 데이터를 응답합니다.

https 는 http연결에 보안을 추가한 프로토콜입니다. ssl 혹은 tsl 기술을 활용하여 암호화를 진행하여 중간에 데이터를 확인할 수 없습니다. 이를 구축하기 위해서는 외부 인증 기관에서 ssl 혹은 tsl 인증서를 획득하고 이를 공유해야합니다.  

++SSL? TSL?

ssl 과 tsl 은 모두 시스템 간의 암호화를 제공합니다. tsl 은 ssl 의 업데이트 버전이며, ssl 은 3.0 버전 이후로 업데이트 되지 않으며, tsl 1.0으로 업데이트를 진행중입니다.

tsl 이 되면서 ssl 에 비해 핸드셰이크 프로세스가 짧아지고 암호화 과정을 줄여 프로세스 속도가 올라갔습니다.
</details>

<details>
 <summary> Spring Bean이란 무엇인가요? </summary>
</br>
 spring은 제어의 역전이 일어나므로, 일부 자바 객체를 관리합니다. 이때 관리되는 자바 객체들을 bean 이라고 부릅니다. 

bean에 객체를 등록하기 위한 방법은 여러가지가 있습니다.

1. xml 파일에 bean 태그를 활용하여 등록 : xml 파일에 bean 태그와 함께 class 의 경로와 property를 입력하면 bean에 등록할 수 있습니다. 
2. component scan : 특정 annotation 을 붙이면 spring이 이를 읽고, 자동으로 bean 객체를 만들어 줍니다.(component, controller, service, repository, configuration …)
    
    이후 xml 파일에 component-scan context 를 통해 annotation이 달린 객체들을 bean으로 만듭니다. ⇒ 이 과정은 ComponentScan annotation 으로 대체될 수 있습니다.
    
3. @Bean annotation 활용 : configuration annotation 과 함께 bean annotation 으로 객체를 return 하는 메소드를 bean으로 등록할 수 있습니다.
</details>

<details>
 <summary> TDD를 알고 있나요? TDD에 대해서 어떻게 생각하나요? </summary>
</br>
 TDD란 테스트 주도 개발으로, 개발을 마치고 테스트를 진행하는 것이 아니라, 테스트를 먼저 준비하고 이에 맞춰 개발을 진행하는 개발 방법을 말합니다. 

장점

1. 설계 수정 시간의 단축 : 테스트 코드를 먼저 작성하기 때문에 입출력 데이터와 기능을 명확하게 하므로 문제를 사전에 발견할 수 있습니다.
2. 유지 보수 용이성 : 기본적으로 단위 테스트를 위한 테스트 코드를 작성하기 때문에, 추후에 모듈 별로 테스트를 진행하면서 유지 보수가 용이해집니다.
3. 테스트 문서 작성 보조 : TDD 를 진행하며 테스트를 자동화시킴과 동시에 더 정확한 테스트 근거로 테스트 문서를 보완할 수 있습니다.

단점

1. 사전 준비 기간 : 프로젝트 도입시 사전에 지식을 습득하고 개발 환경 구축하는 데에 많은 시간이 걸린다. TDD 를 효과적으로 사용할 수 있는 수준의 교육에는 수준에 따라 1~6개월이 걸립니다.
2. 생산성 저하 : 개발 기간이 짧은 경우 TDD 를 이용해 테스트 코드를 작성하고 이를 통과하기 위한 코드를 작성한다면 개발 기간이 그만큼 더 부족해 질 수 있습니다.
</details>

조준희
<details>
 <summary> 프로세스 동기화란? </summary>
</br>
 하나의 자원을 한 순간에 하나의 프로세스만이 이용하도록 제어하는 것.

 여러 프로세스들이 동시에 자원에 접근하는 상황에서 실행 순서에 따라 결과값이 달라질 수 있는데, 이 상황을 경쟁 상태(Race Condition)이라고 한다. 이런 경쟁 상태가 발생하면 자원의 일관성이 깨질 수 있는 문제가 발생한다. 그리고 이 동일한 자원에 접근하는 코드 부분을 Critical Section(임계구역)이라고 한다.

 이런 문제를 해결하기 위한 3가지 방법이 존재한다.
 1. Mutual Exclution(상호 배제)
    - 이미 한 프로세스가 Critical Section(임계 구역)에서 작업 중이면 다른 모든 프로세스는 임계구역에 진입해서는 안된다.
 2. Progress(진행)
    - 임계구역에서 작업 중인 프로세스가 없다면, 임계구역에 진입하고자 하는 프로세스가 존재하는 경우 진입할 수 있어야 한다.
 3. Bounded Waiting(한정 대기)
    - 프로세스가 임계구역에 들어가기 위해 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계구역에 들어가는 횟수에 한계가 있어야 한다. 즉, 임계구역에 진입하려고 프로세스가 무한정 기다려서는 안된다.
</details>

<details>
 <summary> 멀티스레드 프로그래밍에 대해 설명해보세요. </summary>
</br>

 하나의 프로세스들이 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 의미한다. 즉, 하나의 프로그램에 동시에 여러개의 일을 수행할 수 있도록 해주는 것이다.
 프로세스를 이용하여 처리하던 일을 쓰레드로 처리할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 또한 스레드 간의 통신이 필요한 경우에도 스레드간에는 데이터와 힙(Heap)영역을 공유하기 때문에 프로세스 간 통신 방법(IPC)에 비해 훨씬 간단하다. 하지만 멀티 쓰레딩 환경에서는 공유하는 영역이 있기 때문에 공유하는 자원에 대해 동기화 작업이 필요하다.
</details>

<details>
 <summary> RDBMS vs NOSQL에 대해서 설명해주세요. </summary>

 RDBMS
 - 관계형 데이터베이스를 의미한다.
 - 테이블 간의 정보가 서로 관계성을 가지고 있는 것이 특징이고, 2차원 행렬로 테이블을 표현하는 데이터베이스이다. 이러한 관계를 통해 테이블 간 join이 가능하다.
 - 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장받을 수 있다.
 - 하지만 이런 정해진 스키마로 인해 스키마가 자주 바뀌는 환경에서는 번거로울 수 있다.
 - ACID 원칙을 기본으로 구성된 방식으로 정확한 데이터 처리가 가능하다.

<br>

 NoSQL
 - Not Only SQL의 약자로, 테이블 간 상호관계가 없는 것이 특징이다. 관계가 없으므로 다른 테이블과 join도 할 수 없다.
 - 많은 양의 데이터를 저장, 처리할 수 있다.
 - RDBMS와 다르게 스키마가 정해져 있지 않아 구조 변경이 용이하고 데이터 형식이 다양하며 바꾸기 쉽다.
 - 스키마가 존재하지 않아서, 데이터의 일관성이 존재하지 않는다. 이로 인해 데이터 중복이 발생할 수 있어서 데이터가 변경될 경우 모든 컬렉션에서 update해야하는 번거로움이 있다.
 - ACID를 보장하지 않는 경우가 있어서, 정확한 데이터 처리보다는 대용량 데이터 처리에 용이하다.
</br>
</details>

## 2023-07-13

정규성
<details>
 <summary> HTTPS에 대해서 설명하고 SSL Handshake에 대해서 설명해보세요. </summary>
</br>
 https 는 http에 보안 절차를 추가한 과정입니다. 이 과정에 SSL/TLS 기술이 추가됩니다. 

SSL 을 활용한 인증을 위해 SSL 핸드셰이크를 진행합니다.

SSL 핸드셰이크과정

1. client hello : 브라우저가 사용하는 SSL 버전과 암호화 방식, 난수를 포함하여 웹 서버에 접속합니다.
2. 웹 서버는 서버 암호화 방식, 서버 공개키, 난수를 포함하여 응답합니다.
3. 브라우저는 자체 내장 공개키를 활용해 서버의 SSL 인증이 유효한지 확인합니다. 
4. 브라우저는 자신의 난수와 서버에서 받은 난수로 데이터를 만들고 이를 공개키로 암호화하여 웹 서버로 보냅니다.
5. 서버는 이를 복호화하여 세션키를 생성합니다. 세션키는 이후 대칭키 암호화에 사용됩니다.
6. 이제 세션키를 활용하여 암호화, 복호화를 진행하며 https 통신을 진행합니다. 이후 통신이 종료되면 세션키를 폐기합니다.
</details>

<details>
 <summary> 프로세스와 스레드의 차이를 설명해보세요. </summary>
</br>
 프로세스는 OS 에서 메모리에 올라와 실행되는 프로그램입니다. CPU를 점유하며, code/data/stack/heap 의 구조로 독립적 메모리를 가집니다.

스레드는 프로세스 내에서 실행되는 작업입니다. 스레드는 프로세스 내에서 stack 을 독립적으로 가지며, code/data/heap 을 공유합니다.

++ 프로세스 통신과 스레드 통신방법의 차이를 말해보세요

프로세스 간 통신에는 파이프, 파일, 소켓 등의 통신 방법을 이용해서 데이터를 주고 받을 수 있습니다.

스레드 간에는 메모리 영역을 공유하기 때문에 별다른 통신과정없이 데이터를 공유할 수 있습니다.

++ 멀티 프로세스와 멀티 스레드의 차이에 대해 말해보세요

멀티 프로세스는 한 프로그램이 여러 개의 프로세스로 구성되는 구조입니다. 각 작업이 나눠져 있기 때문에 한 프로세스에 문제가 생겨도 다른 프로세스에 직접적으로 문제가 발생하지 않습니다. 다만 각 프로세스가 한 처리 단위이기 때문에 context switching 이 발생하며 이 과정에서 오버헤드가 발생할 수 있습니다.

멀티 스레드는 한 프로그램이 여러개의 스레드로 구성되는 구조입니다. 프로세스 할당에 자원이 사용되지 않으므로 자원을 효율적으로 사용합니다. 다만 한 프로세스에서 다른 프로세스의 스레드를 제어할 수는 없기 때문에 결국 프로세스 간 통신이 필요하며, 자원을 공유하기 때문에 동기화 문제가 발생할 수 있습니다.
</details>

<details>
 <summary> Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요? </summary>
</br>
 checked exception 은 java 에서 반드시 try-catch 문으로 묶어서 예외 처리가 필요한 exception 입니다. unchecked exception 은 runtimeException 을 상속받는 exception 입니다.

스프링 트랜젝션을 추상화 했다면 별도의 commit, rollback 시점을 지정하지 않았기 때문에, uncheckedException이 발생했다면 rollback, checkedException 이 발생했다면 rollback하지 않습니다.

++ 스프링 트랜잭션 추상화에 대해 설명해보세요

DB와의 connection을 통해 직접 트랜젝션을 수행한다면 JDBC, JPA 등특정 구현기술에 종속됩니다. 이를 방지하기 위해 트랜잭션 관리자를 사용합니다. 트랜잭션 관리자라 connection 을 담당하면 사용자는 connection 과 상관 없이 같은 서비스 코드로 요청을 보내면 됩니다.
</details>

조준희
<details>
 <summary> Spring DI/IoC에 대해 설명해시오 </summary>
</br>
IoC는 "제어의 역전" 이라는 의미로, 객체나 메서드의 호출을 개발자가 결정하는 것이 아닌, 객체의 생성에서부터 생명주기의 관리까지 모든 객체에 대한 제어권을 프레임워크 내부에서 결정한다는 의미이다.

DI "의존성 주입" 은 스프링 프레임워크에서 지원하는 IoC의 한 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.
의존성 주입의 방법으로슨 생성자 주입, setter 주입, 필드 주입이 있다.

스프링에서는 스프링 컨테이너(Application Context)를 이용하여 설정 정보를 생성, 등록하고 필요한 객체를 생성자, setter, 필드를 통해 주입합니다.
 
</details>

<details>
 <summary> Spring Bean이란 무엇인가요? </summary>
</br>
우리가 알던 기존의 Java Programming 에서는 Class를 생성하고 new를 입력하여 원하는 객체를 직접 생성한 후에 사용했었습니다. 하지만 Spring에서는 직접 new를 이용하여 생성한 객체가 아니라, Spring에 의하여 관리당하는 자바 객체를 사용합니다. 이렇게 Spring에 의하여 생성되고 관리되는 자바 객체를 Bean이라고 합니다. Spring Framework 에서는 Spring Bean 을 얻기 위하여 ApplicationContext.getBean() 와 같은 메소드를 사용하여 Spring 에서 직접 자바 객체를 얻어서 사용합니다.

Bean 생성은 @component, @Controller, @Service, @Repository과 같은 어노테이션으로 등록이 가능하며,  Bean Configuration File에 직접 Bean 등록하는 방법이 있습니다.
</details>

<details>
 <summary> Servlet Filter와 Spring Interceptor의 차이는 무엇인가요? </summary>
</br>
 필터는 말 그대로 요청과 응답을 거른뒤 정제하는 역할을 한다.
Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공한다.
즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리되는 것이다.
 보안 및 인증/인가 관련 작업, 모든 요청에 대한 로깅 또는 검사, 데이터 압축 및 문자열 인코딩, Spring과 분리되어야 하는 기능에 사용된다.

 인터셉터는 요청에 대한 작업 전 / 후로 가로챈다고 보면 된다.
Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.
웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작한다.
세부적인 보안 및 인증/인가 공통 작업, API 호출에 대한 로깅 또는 검사, Controller로 넘겨주는 정보(데이터)의 가공에 사용된다.
</details>

## 2023-07-14

정규성
<details>
 <summary> 1 </summary>
</br>
</details>

<details>
 <summary> 2 </summary>
</br>
</details>

<details>
 <summary> 3 </summary>
</br>
</details>

조준희
<details>
 <summary> HTTP와 HTTPS의 차이점에 대해서 설명해보세요.</summary>
</br>
- HTTP와 HTTPS의 가장 큰 차이는 보안이다. HTTP의 문제점은 서버에서부터 전달되는 데이터가 암호화가 되지 않은 평문이기ㅎㅎ 때문에, 제 3자가 중간에 개입하여 정보를 탈취할 수 있다는 문제점을 가지고 있다. 이 문제점을 해결하기 위해 나온것이 바로 HTTPS.  HTTPS 프로토콜은 TCP전송 계층 위에 SSL 보안 소켓 계층이 올라가서 서버와 브라우저간의 암호화된 연결을 만들게해주고, 이는 제 3자로부터의 데이터 탈취를 방지해준다. 따라서 HTTPS는 서버에서 전송할 내용을 공개키 또는 개인키로 암호화하여 SSL 인증서를 클라이언트에게 보낸다. 이렇게 되면 중간에 탈취가 되어도 암호화가 되어있어 개인정보가 침해되지않는다. 클라이언트는 이 SSL 인증서를 받게되면 공개키로 암호화되었다면 개인키로, 개인키로 암호화되었다면 공개키로 복호화하여 데이터를 전달 받게된다.
</details>

<details>
 <summary> 컨텍스트 스위칭에대해 설명해보시오. </summary>
</br>
- 여러 실행되고 있는 프로그램, 즉 프로세스들이 동시에 실행되고있는거 같지만 사실 운영체제는 시분할을 이용해서 굉장히 빠른속도로 여러 프로세스들을 번갈아가며 처리해서 마치 동시에 처리되는것처럼 보이는 것이다. 이때 인터럽트가 발생하면 CPU가 다음에 실행될 프로세스를 가져오고 레지스터에 해당 프로세스 정보를 저장한다. 그리고 기존에 실행중이던 프로세스는 PCB에 프로세스 정보를 저장하고 실행이 종료되는 것이다. 이 과정을 컨텍스트 스위칭이라고 한다. 첨언하자면, 이 컨텍스트 스위칭 과정에서는 CPU가 아무런 일을 하지 않으므로 잦은 프로세스 변경은 성능 저하로 이어질 수 있다.
</details>

<details>
 <summary> 강한결합과 느슨한결합에 대해 설명해보시오.</summary>
</br>
- 객체의 의존 관계에서 강한 결합이란, 어떠한 객체가 다른 객체에 강한 의존성을 가지고 있음을 뜻한다. 쉽게 말하면 한 객체 클래스내에서 다른 객체를 직접 생성한다면 객체간의 강한 결합이라고 할 수 있다. 이렇게되면 클래스안에서 생성했었던 객체 정보가 바뀌게 된다면, 해당 클래스에서도 그 객체와 관련한 코드들을 수정해주고 이는 유지보수에 어려움을 일으킵니다. 이에 반해 느슨한 결합은 interface를 통해 구현이 가능한데, 객체 클래스에서는 다른 객체를 직접 생성하지않고, 생성자나 setter, 일반 메서드를 통해 해당 객체를 외부에서 매개변수로 받는다. 이때 받는 인자를 interface로 선언하여 외부에서 객체 정보가 바뀌어도 interface에 대한 또 다른 구현체일테니, 자바의 다형성의 특징때문에 주입받는 객체와 연결되어있는 인자정보를 바꿀 필요가 없고 이는 유지보수성이 용이하다고 할 수 있다.
</details>
