# CS-Study


## 2023-07-10

정규성
<details>
 <summary> OSI7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명해보세요. </summary>
</br>
    
   OIS7계층은 네트워크 통신이 일어나는 과정을 7단계로 나눈것이다. 이렇게 하면 통신이 일어나는 과정을 단계별로 파악할 수 있으며, 문제가 발생할 경우 해당 부분만을 고쳐서 해결할 수 있다. 다만 실제로 구현한 예는 거의 없다.
    
   1. 물리계층 : 신호로 변환하여 전송하는 계층 (허브, 케이블)
   2. 데이터 링크 계층 : 패킷 데이터를 실어 보내는 계층 (스위치, 브릿지)
   3. 네트워크 계층 : 네트워크를 논리적으로 구분하고 연결하는 계층(라우터 + 라우팅 프로토콜)
   4. 전송  계층 : 서비스를 구분하고 데이터의 전송 방식을 담당하는 계층(TCP, UDP)
   5. 세션 계층 : 응용 프로그램 간의 연결을 지원해주는 계층
   6. 표현 계층 : 데이터의 변환 작업을 하는 계층(데이터 암호화, 복호화)
   7. 응용 계층 : User Interface 를 제공하는 계층(chrome, discord, 한글)
    
  그에 비해 TCP/IP 4계층은 실질적인 네트워크 통신에 사용된다. 7계층의 1, 2 가 하나로 통합되고, 5, 6, 7 이 하나로 통합된다. 
    
   1. Network Access Layer : 네트워크 카드와 디바이스 드라이버 등과 같이 하드웨어적인 요소와 관련되 는 모든 것을 지원하는 계층(CSMA/CD, MAC, LAN + Ehternet(이더넷), Token Ring, PPP)
   2. Internet Layer : 상위 트랜스포트 계층으로부터 받은 데이터에 IP패킷 헤더를 붙여 IP패킷을 만들고 이를 전송하는 계층(IP, ARP, RARP)
   3. Transport Layer : 네트워크 양단의 송수신 호스트 사이에서 신뢰성 있는 전송기능을 제공(TCP, UDP)
   4. Application Layer : 응용프로그램들이 네트워크서비스, 메일서비스, 웹서비스 등을 할 수 있도록 표준적인 인터페이스를 제공(HTTP, FTP, Telnet, DNS, SMTP)

    
   </p>
</details>

<details>
 <summary> 프로세스 동기화에 대해 설명해보세요. </summary>
 <div markdown="1">
  </br>
  두 개 이상의 프로세스가 동일한 자원에 접근하면 데이터의 일관성을 해칠 수 있다.
    
   이런 상황을 경쟁상황(race condition)이라고 부른다.
    
   이런 상황을 유발할 수 있는 코드를 임계 구역(Critical Section)이라고 부른다.
    
   이를 해결하기 위해서는 3가지 조건을 만족해야한다.
    
   1.  Mutual Exclusion (상호 배제)
        
        이미 한 프로세스가 Critical Section에서 작업 중이면 다른 모든 프로세스는 Critical Section에 진입하면 안 된다.
        
   2. Progress (진행)
        
        Critical Section에서 작업 중인 프로세스가 없다면, Critical Section에 진입하고자 하는 프로세스가 존재하는 경우 진입할 수 있어야 한다.
        
   3. Bounded Waiting (한정 대기)
        
        프로세스가 Critical Section에 들어가기 위해 요청한 후부터, 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에 한계가 있어야 한다. 쉽게 말해, Critical Section에 진입하려는 프로세스가 무한정 기다려서는 안 된다. 
        
        ⇒ 모종의 이유로 아무도 사용하지 않는 자원을 무한정 기다려서는 안된다.
</details>
   
<details>
 <summary> RDBMS vs NOSQL에 대해서 설명해주세요. </summary>
 </br>
 <div markdown="1">
  <p>RDBMS 는 정해진 스키마에 따라 데이터를 저장하고 구성된 테이블이 다른 테이블과 관계를 맺는다. 이를 위해 외래키를 사용하며, 이를 통해 테이블을 통합하여 데이터를 얻을 수 있다. 데이터 구조화하여 정의하기 편하다. 성능향상을 위해서 서버의 처리 능력 향상이 필요하다. scale up</p>

    
   <p>NOSQL 은 테이블 간의 관계를 정의하지 않고 저장한다. 데이터의 일관성을 포기하고 빅데이터 트래픽 처리에 장점을 가진다. 성능향상을 위해서 분산처리를 지원한다. scale out(수평 확장)</p>
</details>
  
조준희
<details>
 <summary> RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요.(보충필요) </summary>
 <div markdown="1">

  REST의 원리를 잘 따르는 시스템, 그중에서도 REST API 설계 규칙을 올바르게 따르는 시스템을 Restful하다고 할 수 있다.
  
  이때 REST란,
  1. HTTP URI 를 통해 자원을 명시하고
  2. HTTP Method(GET, POST, PUT, DELETE) 를 통해
  3. 해당 자원에 대한 CRUD(생성, 조회, 수정, 삭제)를 적용하는 것을 의미한다.

  라고 보통 알고있는데, "REST란 HTTP 를 잘 사용하기 위한 아키텍쳐 스타일"이 더 알맞다.

  REST의 특징으로는,
  1. Client-Server
     - API를 통해 정보를 교환하는 주체는, 클라이언트와 서버 구조를 가져야한다.
     - 클라이언트와 서버를 분리함으로써, 서로 의존하지 않는 구조를 가져야한다.
  2. Stateless
     - 무상태성 (서로의 상태를 기억하지 않는다.)
     - 클라이언트에서 서버로의 요청에는 그 요청을 이해하는 데 필요한 모든 정보가 포함되어있어야한다.
  3. Cache
     - cache-control header를 통해 요청에 대한 응답 내의 데이터에 캐시 가능여부가 명시되어 있어야한다.
  4. Uniform Interface (.....? 이해가 안간다.. 이건...)
     - 전체 시스템을 파악할 수 있는 인터페이스를 제공해야한다.
  5. Layered System
     - 계층화 시스템
     - 클라이언트는 서버에 직접 연결되었는지, 중간 서버를 통해 연결되었는지 알 수 없어야함을 의미합니다.
     
  또한 REST API란, REST 한 방식으로 데이터를 상호교환 하도록 설계된 API를 의미하고, 이를 올바르게 설계하기 위한 규칙이 존재한다.
  1. URI는 동사보다 명사를, 대문자보다는 소문자를 사용해야한다.
  2. 마지막에 슬래시(/)를 사용해서는 안된다.
  3. 언더바 대신, 하이픈(-)을 사용한다.
  4. 파일확장자는 URI에 포함하지 않는다.
  
</details>

<details>
 <summary> 프로세스와 스레드의 차이를 설명해보세요. </summary>
 <div markdown="1">
  프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.
  
  프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)를 사용해야 한다.
  
  이에 반해 스레드는 한 프로세스 내에서 각각 Stack만 따로 할당받고, Code, Data, Heap 영역에서 서로 자원을 공유하고 접근할 수 있다. 따라서 프로세스간 통신이 불가해서 오는 컨텍스트 스위칭 비용, 프로세스간 통신(IPC)비용을 줄일 수 있는 이점이 있다. 하지만 스레드 간의 자원 공유는 동기화 문제가 발생할 수 있다는 특징이 있다.

+ 추가 질문 ( 컨텍스트 스위칭, IPC에 대해 설명해봐라, 메모리 영역(Code, Data, Stack, Heap)에 대해 설명해봐라, 동기화 문제는 무엇이고 어떻게 해결해야하는가?)
</details>
   
<details>
 <summary> ACID에 대해서 설명해주세요. </summary>
 <div markdown="1">

  Atomicity 원자성
  - 하나의 트랜잭션에 속한 모든 작업이 "전부 성공하거나 전부 실패"하는 것을 보장한다.

  Consistency 일관성
  - 트랜잭션이 성공적으로 끝나면 데이터베이스의 제약/규칙과 같은 상태는 언제나 이전과 같고 유효해야한다.

  Isolation 독립성
  - 트랜잭션은 다른 트랜잭션의 연산에 영향을 끼치지 못하는 것을 보장한다.
  - 모든 트랜잭션은 다른 트랜잭션으로부터 독립 되어야한다.

  Durabilty 지속성
  - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
</details>


## 2023-07-11

정규성
<details>
 <summary> apache 와 nginx, tomcat 의 역할과 차이점 </summary>
</br>
    apache는 웹 서버의 역할을 합니다. 멀티 프로세스 방식으로 동작하며 안정성에 장점이 있습니다. 다만 모든 연결에 프로세스를 할당하다보니 성능이 비교적 떨어집니다.

nginx는 마찬가지로 웹 서버의 역할을 하지만, 이벤트 기반 방식으로 동작합니다. 여기서 이벤트 기반 방식이란, 연결 요청이 nginx 가 가진 큐에 차례로 들어있다가 하나씩 요청을 스레드를 할당해 처리합니다. 이때 연결에서 별다른 요청이 없다면 다른 연결의 요청을 처리하는 방식입니다. 이를 통해 가볍고 성능이 비교적 좋습니다.

tomcat은 웹 어플리케이션 서버의 역할을 합니다. JAVA로 작성된 프로그램으로, http 요청을 받고 동적인 페이지를 만들어 제공하는 것이 목적으로 합니다. 웹 서버와 같이 연동해서 사용하면 성능을 향상시킬 수 있습니다.
   
</details>

<details>
 <summary> 컨텍스트 스위칭에 대해 설명해보세요. </summary>
</br>
   컨텍스트 스위칭은 여러개의 프로그램이 동시에 실행되는 경우 프로세스의 처리를 빠르게 바꿔가며 하기 위해 필요한 기술입니다.

이를 위해, 한 프로세스로 부터 CPU자원을 프로세스로 넘겨줍니다. cpu가 프로세스를 동작시킬 때 필요한 정보를 context라고 하며, 이 정보가 PCB에 저장됩니다. A프로세스가 실행중에 스케쥴러에 의해 B 프로세스의 실행을 요청하면 A의 정보를 PCB에 저장하고, B의 정보를 PCB로 부터 불러와서 작업을 진행합니다. 이럼

이때 어떤 프로세스를 요청할 지 여부를 결정하는 스케쥴링 방식에 따라 성능이 달라질 수 있으며, 이 과정이 과도하게 일어날 경우 오버헤드가 발생하며 오히려 성능이 저하될 수 있다.
   
</details>

<details>
 <summary> 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요. </summary>
</br>
   데이터베이스에서 인덱스를 사용하는 이유는 테이블에 대한 동작의 속도를 높이기 위해서입니다. 인덱스를 key-value 구조로 이루어지며, 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬하여 별도의 메모리 공간에 실제 메모리 주소와 함께 저장한다. 이를 구현하기 위해 여러 방법이 있지만, 주로 B+Tree 구조를 사용한다. B+tree 의 경우 balanced-tree 구조로 설계되어 수직탐색에 유리하며, leaf 노드에만 데이터를 저장하고 이를 linked-list로 연결하여 수평탐색에도 유리하다.
   
</details>

조준희
<details>
 <summary> TCP와 UDP의 차이점에 대해서 설명해보세요. </summary>
</br>
 TCP는 데이터의 신뢰성을 보장하는 연결 지향적 프로토콜이다.
 데이터의 손실이 없고, 순서대로 전달된다는 특징을 가지고 있다.
 TCP는 데이터를 전송하기 전에 송수신 기기간 논리적 연결을 하고, 이를 가상 회선이라고 한다.
 이렇게 생성된 회선을 통해 송신자는 패킷 전송이 잘 되었는지 확인하는 과정과 흐름제어 혼잡 제어와 같은 과정을 거치면서 패킷의 순서와 손실을 방지하면서 데이터 전송이 가능하게 해준다.

 UDP는 데이터의 신뢰성 보다는 전송 속도를 위한 비연결 지향적 프로토콜이다.
 데이터의 손실 가능성이 있어 데이터의 신뢰성은 보장할 수 없지만, 빠르게 데이터를 전송할 수 있다는 특징을 가지고 있다.
 UDP는 TCP와 다르게 가상회선 방식과 같이 연결을 설정하지 않고, 독집적인 데이터그램 형태로 패킷마다 각각 다른 경로로 수신자에게 보내지게된다. 이 때문에 데이터의 순서가 보장되지 못하며, 패킷이 잘 도착했는지 또는 흐름 제어와 혼잡 제어같은 기능을 처리하지 않기 때문에 데이터의 손실이 발생할 수 있다. 하지만 이로인해 네트워크 부하가 적어서 TCP보다 전송 속도가 빠르다.
</details>

<details>
 <summary> 동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요. </summary>
</br>
동기방식 : 호출된 함수의 수행 결과 및 종료를 호출한 함수가 신경쓰는 방식

비동기 방식 : 호출된 함수의 수행 결과 및 종료를 호출한 함수가 신경쓰지 않는 방식

블로킹 : 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않는 방식

논-블로킹 : 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return 하여 호출한 함수가 다른 일을 진행할 수 있도록 하는 방식

동기 & 블로킹, 비동기 & 블로킹 : 결국 호출된 함수가 끝날 때를 기다려야 하기 때문에 동기, 비동기에 상관없이 블로킹이라면 비슷한 효율을 가진다.

동기 & 논-블로킹 : 호출된 함수로부터 제어권을 바로 return 받아서 다른 작업을 수행할 수는 있지만 다른 작업을 하면서도 동기방식이기 때문에 호출된 함수의 결과를 계속 신경 쓰게 된다. 이로 인해 작업의 효율이 좋지 못하다.

비동기 & 논-블로킹 : 호출된 함수의 결과를 기다리지도 않으며 자신의 작업을 계속 수행하고, 콜백을 통해 호출된 함수의 결과를 받는다. 그렇기 때문에 자원이 충분하다면 효율이 좋은 방식이다.
   
</details>

<details>
 <summary> 정규화에 대해서 설명해주세요. </summary>
</br>
정규화의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는 것으로, 중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며, DB간의 저장 용량 역시 줄일 수 있는 방법이다.

따라서 테이블을 분해하는 여러 단계로 정의된다.

[제1정규화]
테이블의 칼럼이 원자값(하나의 값)을 갖도록 테이블을 분해한다.

[제2정규화]
테이블의 기본키의 부분집합이 결정자가 되어서는 안된다.
ex) 복합키 (A,B)가 기본키로 된 테이블에서 B만으로도 C가 달라지는 상황이 발생하면, 
B가 결정자가 되므로 이는 제2정규화의 대상이 된다.

[제3정규화]
테이블에 대해 이행적 종속을 없앤다.
여기서 이행적 종속이란 A -> B, B -> C 가 성립할 때, A-> C가 성립되는 상황을 의미한다.

[BCNF 정규화]
테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.
   
</details>



## 2023-07-12

정규성
<details>
 <summary> 1 </summary>
</br>
</details>

<details>
 <summary> 2 </summary>
</br>
</details>

<details>
 <summary> 3 </summary>
</br>
</details>

조준희
<details>
 <summary> 프로세스 동기화란? </summary>
</br>
 하나의 자원을 한 순간에 하나의 프로세스만이 이용하도록 제어하는 것.

 여러 프로세스들이 동시에 자원에 접근하는 상황에서 실행 순서에 따라 결과값이 달라질 수 있는데, 이 상황을 경쟁 상태(Race Condition)이라고 한다. 이런 경쟁 상태가 발생하면 자원의 일관성이 깨질 수 있는 문제가 발생한다. 그리고 이 동일한 자원에 접근하는 코드 부분을 Critical Section(임계구역)이라고 한다.

 이런 문제를 해결하기 위한 3가지 방법이 존재한다.
 1. Mutual Exclution(상호 배제)
    - 이미 한 프로세스가 Critical Section(임계 구역)에서 작업 중이면 다른 모든 프로세스는 임계구역에 진입해서는 안된다.
 2. Progress(진행)
    - 임계구역에서 작업 중인 프로세스가 없다면, 임계구역에 진입하고자 하는 프로세스가 존재하는 경우 진입할 수 있어야 한다.
 3. Bounded Waiting(한정 대기)
    - 프로세스가 임계구역에 들어가기 위해 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계구역에 들어가는 횟수에 한계가 있어야 한다. 즉, 임계구역에 진입하려고 프로세스가 무한정 기다려서는 안된다.
</details>

<details>
 <summary> 멀티스레드 프로그래밍에 대해 설명해보세요. </summary>
</br>

 하나의 프로세스들이 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 의미한다. 즉, 하나의 프로그램에 동시에 여러개의 일을 수행할 수 있도록 해주는 것이다.
 프로세스를 이용하여 처리하던 일을 쓰레드로 처리할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 또한 스레드 간의 통신이 필요한 경우에도 스레드간에는 데이터와 힙(Heap)영역을 공유하기 때문에 프로세스 간 통신 방법(IPC)에 비해 훨씬 간단하다. 하지만 멀티 쓰레딩 환경에서는 공유하는 영역이 있기 때문에 공유하는 자원에 대해 동기화 작업이 필요하다.
</details>

<details>
 <summary> RDBMS vs NOSQL에 대해서 설명해주세요. </summary>

 RDBMS
 - 관계형 데이터베이스를 의미한다.
 - 테이블 간의 정보가 서로 관계성을 가지고 있는 것이 특징이고, 2차원 행렬로 테이블을 표현하는 데이터베이스이다. 이러한 관계를 통해 테이블 간 join이 가능하다.
 - 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장받을 수 있다.
 - 하지만 이런 정해진 스키마로 인해 스키마가 자주 바뀌는 환경에서는 번거로울 수 있다.
 - ACID 원칙을 기본으로 구성된 방식으로 정확한 데이터 처리가 가능하다.

<br>

 NoSQL
 - Not Only SQL의 약자로, 테이블 간 상호관계가 없는 것이 특징이다. 관계가 없으므로 다른 테이블과 join도 할 수 없다.
 - 많은 양의 데이터를 저장, 처리할 수 있다.
 - RDBMS와 다르게 스키마가 정해져 있지 않아 구조 변경이 용이하고 데이터 형식이 다양하며 바꾸기 쉽다.
 - 스키마가 존재하지 않아서, 데이터의 일관성이 존재하지 않는다. 이로 인해 데이터 중복이 발생할 수 있어서 데이터가 변경될 경우 모든 컬렉션에서 update해야하는 번거로움이 있다.
 - ACID를 보장하지 않는 경우가 있어서, 정확한 데이터 처리보다는 대용량 데이터 처리에 용이하다.
</br>
</details>
